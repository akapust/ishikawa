<script>
(function(){
  const ROOT = document.getElementById("vuca-decider-v3");
  if(!ROOT) return;

  const STORAGE_KEY = "vuca_decider_v3_state";
  const LANG_KEY = "qmLang";

  const $ = (sel) => ROOT.querySelector(sel);
  const $$ = (sel) => Array.from(ROOT.querySelectorAll(sel));

  // ----------------------------
  // i18n
  // ----------------------------
  const I18N = {
    de: {
      // General
      langLabel: "Sprache",
      badgeDecision: "Decision Tool",
      badgeDefinition: "Definition",
      badgeCase: "Fall",
      badgeAssessment: "Bewertung",
      badgeVisuals: "Visuals",
      badgeTools: "Tools",
      badgeRoadmap: "Roadmap",
      badgeExport: "Export",

      // Section titles/subs
      sec1Title: "1. VUCA Entscheidungsfinder",
      sec1SubHtml:
        'Ein Tool, das einen Fall in <strong>VUCA-Druck</strong> (V/U/C/A) und <strong>VUCA Prime-Reifegrad</strong> (Vision/Understanding/Clarity/Agility) übersetzt – inklusive <strong>Toolvorschlägen</strong> und <strong>Roadmap</strong>.',
      goalTitle: "Ziel des Tools",
      goalListHtml: [
        "<strong>Situation strukturieren</strong>: nicht “ein Gefühl”, sondern ein Profil.",
        "<strong>Entscheidungslogik ableiten</strong>: pro Welt PDCA vs. DCPA.",
        "<strong>Werkzeugkasten liefern</strong>: pro Dimension konkrete Methoden.",
        "<strong>Gaps sichtbar machen</strong>: Wo ist der Druck höher als der Reifegrad?"
      ].map(li=>`<li>${li}</li>`).join(""),
      howTitle: "So nutzt du es (3 Schritte)",
      howListHtml: `
        <li><strong>Fall ausfüllen</strong> (Titel, Kontext, Ziel).</li>
        <li><strong>Bewerten</strong>:
          <ul class="vuca-list">
            <li>Bis zu 4 <strong>Welten</strong> anlegen (W1–W4) und V/U/C/A per Schieber setzen.</li>
            <li><strong>VUCA Prime</strong>: 5 Fragen je Buchstabe (Grün/Gelb/Rot) beantworten.</li>
          </ul>
        </li>
        <li><strong>Entscheidung lesen</strong>: Radar + Matrix + Gap → Toolvorschläge + Roadmap.</li>
      `,
      sec1NoteHtml:
        '<strong>Wichtig:</strong> Beispieltexte erscheinen nur in <em>Platzhaltern</em>. Wenn Felder leer sind, bleibt der Output neutral (—).',

      sec2Title: "2. Definition & Logik",
      sec2Sub: "VUCA beschreibt die Umwelt (Druck). VUCA Prime beschreibt die Antwortfähigkeit (Reifegrad).",
      sec2LeftTitle: "VUCA-Druck (Input)",
      sec2LeftText: "Du bewertest V/U/C/A je Welt mit Schiebern (1–5). Daraus entstehen Radar & Matrix.",
      sec2RightTitle: "VUCA Prime-Reifegrad (Reaktion)",
      sec2RightText:
        "Pro Buchstabe 5 Fragen (Grün/Gelb/Rot). Daraus entsteht ein Reifegradprofil (1–5), das wir gegen den VUCA-Druck spiegeln → VUCA Gap.",
      sec2Hint:
        "<strong>Erkenntnis-Logik:</strong> Hoher Druck + niedriger Reifegrad = prioritär handeln (Gap schließen). Hoher Druck + hoher Reifegrad = skalieren/standardisieren.",

      sec3Title: "3. Fallbeschreibung",
      sec3Sub: "Diese Felder steuern den Ergebnis-Header unten (live).",
      labelCaseTitle: "Titel",
      phCaseTitle: "z.B. Kein ESD-Verpackungsmaterial am Markt verfügbar",
      labelCaseTeam: "Kontext / Team",
      phCaseTeam: "z.B. Einkauf / Produktion / Qualität",
      labelCaseDesc: "Kurzbeschreibung (2–3 Sätze)",
      phCaseDesc: "Was passiert, was ist unklar/instabil, wo drückt es?",
      labelCaseGoal: "Ziel / Outcome",
      phCaseGoal: "z.B. Versorgung sichern, Lieferfähigkeit stabilisieren, Risiken minimieren",
      btnResetCase: "Felder leeren",
      btnBackup: "Backup (Browser)",
      btnRestore: "Backup laden",
      btnClearAll: "Alles löschen",

      sec4Title: "4. Bewertung",
      sec4Sub: "Lege bis zu 4 Welten an (W1–W4). Jede Welt kann eine andere Entscheidungslogik brauchen.",
      aTitle: "A) VUCA je Welt (Schieber 1–5)",
      aHint: "Live-Update: Schieber bewegen → Radar/Matrix/Gap aktualisieren sofort.",
      btnAddWorld: "Welt hinzufügen",
      worldListAria: "Welten Liste",
      chipWorld: "Welt",
      removeWorld: "Entfernen",
      worldMini: "Optional: kurze Notiz (bleibt leer, wenn du nichts einträgst).",
      worldNameLabel: "Name",
      worldNamePh: "z.B. Versorgung sichern / Alternativen testen",
      worldNoteLabel: "Notiz (optional)",
      worldNotePh: "z.B. Fokus / Hypothese / Messpunkt (optional)",
      valueLabel: "Wert",
      dims: {
        V: "Volatilität",
        U: "Unsicherheit",
        C: "Komplexität",
        A: "Ambiguität"
      },

      bTitle: "B) VUCA Prime Reifegrad (Highlight)",
      bHintHtml:
        '5 Fragen je Dimension – Antworten als <span class="pill green">Grün</span> / <span class="pill yellow">Gelb</span> / <span class="pill red">Rot</span>. <strong>Erst hier</strong> wird die Roadmap “intelligent”.',
      primeMeta: "5 Fragen · Grün/Gelb/Rot",
      tl: [
        {k:"red", label:"Rot", v:1},
        {k:"yellow", label:"Gelb", v:2},
        {k:"green", label:"Grün", v:3},
      ],
      prime: [
        {
          key:"V",
          name:"Vision (Antwort auf Volatilität)",
          hint:"Orientierung geben, kurz takten, trotzdem stabil entscheiden.",
          qs:[
            "Wir haben einen klaren Nordstern (Vision), der Entscheidungen leitet.",
            "Prioritäten sind für die nächsten 2–4 Wochen verbindlich sichtbar.",
            "Es gibt klare Entscheidungsregeln (was wird sofort entschieden, was eskaliert?).",
            "Wir planen rollierend (Rhythmus) statt starr (Jahresplan).",
            "Puffer/Reserven sind bewusst eingeplant (Zeit, Kapazität, Budget)."
          ]
        },
        {
          key:"U",
          name:"Understanding (Antwort auf Unsicherheit)",
          hint:"Hypothesen statt Behauptungen – Lernen schneller als Raten.",
          qs:[
            "Annahmen sind sichtbar (Hypothesen-Backlog/Decision Log).",
            "Wir nutzen Pre-Mortem oder Risiko-Checks vor wichtigen Schritten.",
            "Wir arbeiten mit Szenarien (best/base/worst) statt “einem Plan”.",
            "Wir reduzieren Unklarheit aktiv durch Daten/Feedback (kurze Zyklen).",
            "Wir testen klein (MVP/Experiment) bevor wir groß investieren."
          ]
        },
        {
          key:"C",
          name:"Clarity (Antwort auf Komplexität)",
          hint:"System verstehen, Fokus schaffen, Hebel erkennen.",
          qs:[
            "Wir verstehen zentrale Wechselwirkungen (System-Map / Ursache-Wirkung).",
            "Stakeholder/Rollen sind klar (Einfluss, Betroffenheit, Owner).",
            "Wir visualisieren Arbeit (Kanban) und begrenzen WIP (Fokus).",
            "Wir vereinfachen bewusst (Hebel/80-20) statt alles gleichzeitig zu lösen.",
            "Wir denken in Zeithorizonten (heute–morgen–übermorgen)."
          ]
        },
        {
          key:"A",
          name:"Agility (Antwort auf Ambiguität)",
          hint:"Gemeinsame Definitionen + schnelle Anpassung im Tun.",
          qs:[
            "Begriffe/Erfolg sind definiert (DoD/DoR, Erfolgskriterien).",
            "Alignment ist explizit (Ziel/Nicht-Ziel, Grenzen, Trade-offs).",
            "Entscheidungen sind rollenbasiert (RACI/DACI) und nachvollziehbar.",
            "Wir nutzen Beispiele/Story-Mapping statt nur Abstraktionen.",
            "Wir iterieren aktiv (Retro/Learnings) und passen Kurs schnell an."
          ]
        }
      ],

      sec5Title: "5. Darstellung (Dashboard)",
      sec5Sub: "3 Ebenen: Radar (Highlight), Matrix, Gap. Jede Grafik exportierbar.",
      vizRadarTitle: "VUCA Meter (Radar) – Multi-Overlay",
      vizRadarSub: "Polygone je Welt + optional Gesamt + Prime-Reifegrad",
      radarBtn: "Radar PNG",
      radarHint:
        "Tipp: In der Legende kannst du Welten ein-/ausblenden. “Prime” zeigt deine Antwortfähigkeit (Vision/Understanding/Clarity/Agility) auf derselben Skala (1–5).",
      vizMatrixTitle: "VUCA Matrix (2×2)",
      vizMatrixSub: "x = U+A (Lernen) · y = V+C (Liefern/Steuern)",
      matrixBtn: "Matrix PNG",
      matrixHint:
        "Punkte W1–W4 zeigen: eine Fallbeschreibung kann mehrere “Welten” enthalten → daher mehrere Punkte.",
      vizGapTitle: "VUCA Gap (Druck ↔ Reifegrad)",
      vizGapSub: "Wo ist der Druck höher als die Antwortfähigkeit?",
      gapBtn: "Gap PNG",
      gapNoData:
        "Noch keine Bewertungen. Lege mindestens eine Welt an und beantworte Prime-Fragen (Grün/Gelb/Rot).",

      sec6Title: "6. Methodenauswahl & Tools (Entscheidungsausgabe)",
      sec6Sub: "Der Output endet mit konkreten Toolvorschlägen – pro Dimension und als Prioritätenliste.",
      autoRecTitle: "Automatische Empfehlung (Top-Prioritäten)",
      autoRecEmpty: "Noch keine Daten. Bewerte Welten und Prime-Fragen.",

      sec7Title: "7. Maßnahmen (Roadmap)",
      sec7Sub: "Pro Welt: vorgeschlagene Schleife (PDCA/DCPA) + nächste Schritte (48h / 2 Wochen / 4–8 Wochen).",

      sec8Title: "8. Export & Daten",
      sec8Sub: "Alle Grafiken exportieren + JSON Import/Export (am Ende, wie gewünscht).",
      exportGraphicsTitle: "Grafik-Export (PNG)",
      exportAllPng: "Ganzes Dashboard PNG",
      exportRadarPng2: "Radar PNG",
      exportMatrixPng2: "Matrix PNG",
      exportGapPng2: "Gap PNG",
      exportHint: "Exports verwenden den aktuellen Stand (live). Ideal für Doku/Slides.",
      jsonTitle: "JSON Import/Export",
      btnExportJson: "JSON speichern",
      btnImportJson: "JSON laden",
      jsonHint: "JSON enthält Fall + Welten + Prime-Antworten. Keine Live-Preview (wie gewünscht).",

      footerLead: "Weiterführend:",
      footerLex: "VUCA Lexikon",
      footerSem: "VUCA Seminar",
      footerOpex: "OPEX Ausbildung",

      // Dynamic / logic strings
      tooltipV: "V – Volatilität / Vision",
      tooltipU: "U – Unsicherheit / Understanding",
      tooltipC: "C – Komplexität / Clarity",
      tooltipA: "A – Ambiguität / Agility",

      dsOverall: "Gesamt (Mittel)",
      dsPrime: "Prime (Reifegrad)",

      axisX: "U + A  →  Lernen / Klärung",
      axisY: "↑  V + C  (Steuern / Liefern)",
      q1Main: "Fokus: Flow",
      q1Sub: "C/V hoch · U/A niedrig",
      q2Main: "Fokus: Lernen",
      q2Sub: "C/V hoch · U/A hoch",
      q3Main: "Fokus: Stabilisieren",
      q3Sub: "C/V niedrig · U/A niedrig",
      q4Main: "Fokus: Experiment",
      q4Sub: "C/V niedrig · U/A hoch",

      overallLabel: "Gesamt",

      tools: {
        V: {
          title: "Volatilität → Vision",
          desc: "Wenn sich Rahmenbedingungen schnell ändern: kurz takten, Orientierung halten.",
          tools: [
            "OODA-Loop (Observe–Orient–Decide–Act)",
            "Rolling Planning / Re-Planungsrhythmus (2–4 Wochen)",
            "MoSCoW / Eisenhower zur Priorisierung",
            "Kanban + WIP-Limits (Fokus statt Parallelität)",
            "Pufferplanung / 15%-Regel (Volatilität einkalkulieren)",
            "OKR (light) für Fokus & Messbarkeit"
          ]
        },
        U: {
          title: "Unsicherheit → Understanding",
          desc: "Wenn Infos fehlen: Hypothesen sichtbar machen, lernen statt raten.",
          tools: [
            "Hypothesen-Backlog / Assumption Log",
            "Pre-Mortem (was könnte schiefgehen?)",
            "Szenariotechnik (best/base/worst)",
            "Cone of Uncertainty (bewusst nachschärfen)",
            "Experimentdesign / MVP-Denken (klein testen)",
            "Entscheidungslog (Decision Log) + Trigger für Re-Bewertung"
          ]
        },
        C: {
          title: "Komplexität → Clarity",
          desc: "Wenn Ursache–Wirkung nicht linear ist: System verstehen, sichere Schritte gehen.",
          tools: [
            "System-Mapping / Causal-Loop Thinking",
            "Stakeholder-Map (Einfluss/Betroffenheit)",
            "Wertstrom-Sicht / Wardley Mapping (light)",
            "Safe-to-fail Experimente (mehrere kleine Versuche)",
            "3 Horizons / Horizon Thinking",
            "A3-Problem Solving (Lean, strukturiert)"
          ]
        },
        A: {
          title: "Ambiguität → Agility",
          desc: "Wenn Begriffe/Ziele unterschiedlich interpretiert werden: gemeinsame Sprache + schnelle Anpassung.",
          tools: [
            "Definition of Done / Definition of Ready",
            "Alignment Canvas (Ziel/Nicht-Ziel, Erfolgskriterien, Grenzen)",
            "RACI / DACI (Rollen & Entscheidungen klären)",
            "Kontext-Check: “Was bedeutet das konkret im Alltag?”",
            "Story Mapping / Beispiele statt Abstraktionen",
            "Retrospektive (Start/Stop/Continue) – Lernen systematisieren"
          ]
        }
      },

      loopNotes: {
        both: "Beidhändig: Delivery + Experiment. Nutze DCPA für Lernen, PDCA für stabile Teilaufgaben.",
        learn: "Hohe Unsicherheit/Ambiguität: zuerst kleine Experimente, dann planen.",
        deliver: "Hohe Volatilität/Komplexität, aber strukturierbar: iterativ planen/umsetzen/prüfen.",
        normal: "Moderate Lage: klein planen, transparent arbeiten, regelmäßig nachschärfen."
      },

      steps48: {
        dcpa: [
          "Do: 1–2 safe-to-fail Experimente definieren (klein, reversibel, Messpunkt).",
          "Check: nach 24–48h Signale sammeln (Daten/Feedback, Abbruchkriterium).",
          "Plan: nächste Hypothese festlegen, Experiment anpassen."
        ],
        pdca: [
          "Plan: Ziel + Scope + Board aufsetzen (Kanban, WIP-Limit).",
          "Do: klein starten (1–2 Lieferpakete), Verantwortlichkeiten klären.",
          "Check: nach 48h Status & Blocker, Anpassungen für den nächsten Zyklus."
        ]
      },
      steps2w: {
        dcpa: [
          "2–3 Experimente parallel (max. 2 Wochen), klare Metriken.",
          "Gewinner skalieren, Verlierer stoppen, Learnings dokumentieren.",
          "Entscheidungslog pflegen: was wurde warum entschieden?"
        ],
        pdca: [
          "Rolling Planning (2 Wochen): Prioritäten fixieren, Rest flexibel.",
          "Risiko-/Pre-Mortem für kritische Pfade.",
          "Review: messbare Ergebnisse + nächste Iteration planen."
        ]
      },
      steps8w: [
        "Stabilisieren & standardisieren: was funktioniert, wird SOP/Checkliste.",
        "Gap schließen: die schwächste Prime-Dimension gezielt verbessern (Training/Prozess).",
        "Messsystem: KPIs + Trigger für Re-Planung definieren."
      ],

      recNoPrime: "Beantworte Prime-Fragen (Grün/Gelb/Rot), damit das Tool die Gap-Prioritäten setzen kann.",
      recTemplate: (topP, topG, avg, r, b) => `
        <div class="vuca-text">
          <strong>Stärkster VUCA-Druck:</strong> ${topP.k} (${topP.v}/5).<br/>
          <strong>Größter Gap:</strong> ${topG.k} (Druck ${avg[topG.k]}/5 vs. Reifegrad ${r}/5 → Gap ${topG.g > 0 ? "+"+topG.g : topG.g}).<br/><br/>
          <strong>Empfohlener Fokus:</strong> <em>${esc(b.title)}</em><br/>
          Starte mit diesen 3 Tools:
          <ul style="margin:8px 0 0 18px;">
            <li>${esc(b.tools[0])}</li>
            <li>${esc(b.tools[1])}</li>
            <li>${esc(b.tools[2])}</li>
          </ul>
        </div>
      `,

      insightNeedPrime: (title, team, goal) => `
        <strong>Fall:</strong> ${title}<br/>
        <span style="color:#64748b">Kontext/Team:</span> <strong>${team}</strong> · <span style="color:#64748b">Ziel:</span> <strong>${goal}</strong><br/><br/>
        <strong>Nächster Schritt:</strong> Prime-Fragen beantworten (Grün/Gelb/Rot), damit das Tool Gap + Roadmap sauber priorisiert.
      `,
      insightTemplate: (title, team, goal, top, worstTxt) => `
        <strong>Fall:</strong> ${title}<br/>
        <span style="color:#64748b">Kontext/Team:</span> <strong>${team}</strong> · <span style="color:#64748b">Ziel:</span> <strong>${goal}</strong><br/><br/>
        <strong>Erkenntnis aus den Fragen:</strong><br/>
        1) Höchster VUCA-Druck ist <strong>${top.k}</strong> (${top.v}/5).<br/>
        2) Größter Gap ist <strong>${esc(worstTxt)}</strong>.<br/>
        3) Empfehlung: Tools zuerst dort einsetzen, wo <strong>Gap</strong> am größten ist (Reifegrad aufbauen), danach stabilisieren/standardisieren.
      `,

      // Toast/confirm
      tFieldsCleared: "Felder geleert.",
      tBackupSaved: "Backup gespeichert.",
      tNoBackup: "Kein Backup gefunden.",
      tBackupLoaded: "Backup geladen.",
      tWorldAdded: "Welt hinzugefügt.",
      tJsonLoaded: "JSON geladen.",
      tJsonInvalid: "JSON ungültig.",
      tJsonLoadFail: "JSON konnte nicht geladen werden.",
      tExportFail: "Export fehlgeschlagen. Prüfe Browserrechte.",
      confirmClearAll: "Alles löschen (Fall, Welten, Prime)?",

      // Section headings inside visuals/export etc that are hardcoded in HTML (we patch)
      sec5RadarLegendAria: "Radar Legende"
    },

    en: {
      langLabel: "Language",
      badgeDecision: "Decision Tool",
      badgeDefinition: "Definition",
      badgeCase: "Case",
      badgeAssessment: "Assessment",
      badgeVisuals: "Visuals",
      badgeTools: "Tools",
      badgeRoadmap: "Roadmap",
      badgeExport: "Export",

      sec1Title: "1. VUCA Decision Finder",
      sec1SubHtml:
        'A tool that translates a case into <strong>VUCA pressure</strong> (V/U/C/A) and <strong>VUCA Prime readiness</strong> (Vision/Understanding/Clarity/Agility) – including <strong>tool suggestions</strong> and a <strong>roadmap</strong>.',
      goalTitle: "Tool goal",
      goalListHtml: [
        "<strong>Structure the situation</strong>: not a gut feel, but a profile.",
        "<strong>Derive decision logic</strong>: PDCA vs. DCPA per world.",
        "<strong>Provide a toolbox</strong>: concrete methods per dimension.",
        "<strong>Make gaps visible</strong>: where is pressure higher than readiness?"
      ].map(li=>`<li>${li}</li>`).join(""),
      howTitle: "How to use it (3 steps)",
      howListHtml: `
        <li><strong>Fill in the case</strong> (title, context, goal).</li>
        <li><strong>Assess</strong>:
          <ul class="vuca-list">
            <li>Create up to 4 <strong>worlds</strong> (W1–W4) and set V/U/C/A with sliders.</li>
            <li><strong>VUCA Prime</strong>: answer 5 questions per letter (Green/Amber/Red).</li>
          </ul>
        </li>
        <li><strong>Read the decision</strong>: radar + matrix + gap → tool suggestions + roadmap.</li>
      `,
      sec1NoteHtml:
        '<strong>Note:</strong> example texts appear only in <em>placeholders</em>. If fields are empty, the output stays neutral (—).',

      sec2Title: "2. Definition & Logic",
      sec2Sub: "VUCA describes the environment (pressure). VUCA Prime describes response capability (readiness).",
      sec2LeftTitle: "VUCA pressure (input)",
      sec2LeftText: "Rate V/U/C/A per world with sliders (1–5). This drives radar & matrix.",
      sec2RightTitle: "VUCA Prime readiness (response)",
      sec2RightText:
        "For each letter: 5 questions (Green/Amber/Red). This forms a readiness profile (1–5), mirrored against pressure → the VUCA gap.",
      sec2Hint:
        "<strong>Insight logic:</strong> High pressure + low readiness = act first (close the gap). High pressure + high readiness = scale/standardize.",

      sec3Title: "3. Case description",
      sec3Sub: "These fields control the result header below (live).",
      labelCaseTitle: "Title",
      phCaseTitle: "e.g., No ESD packaging material available on the market",
      labelCaseTeam: "Context / team",
      phCaseTeam: "e.g., Purchasing / Production / Quality",
      labelCaseDesc: "Short description (2–3 sentences)",
      phCaseDesc: "What is happening, what is unclear/unstable, where is the pressure?",
      labelCaseGoal: "Goal / outcome",
      phCaseGoal: "e.g., secure supply, stabilize delivery performance, minimize risks",
      btnResetCase: "Clear fields",
      btnBackup: "Backup (browser)",
      btnRestore: "Load backup",
      btnClearAll: "Delete everything",

      sec4Title: "4. Assessment",
      sec4Sub: "Create up to 4 worlds (W1–W4). Each world may need a different decision loop.",
      aTitle: "A) VUCA per world (sliders 1–5)",
      aHint: "Live update: move sliders → radar/matrix/gap update instantly.",
      btnAddWorld: "Add world",
      worldListAria: "World list",
      chipWorld: "World",
      removeWorld: "Remove",
      worldMini: "Optional: short note (stays empty if you don’t enter anything).",
      worldNameLabel: "Name",
      worldNamePh: "e.g., secure supply / test alternatives",
      worldNoteLabel: "Note (optional)",
      worldNotePh: "e.g., focus / hypothesis / metric (optional)",
      valueLabel: "Value",
      dims: {
        V: "Volatility",
        U: "Uncertainty",
        C: "Complexity",
        A: "Ambiguity"
      },

      bTitle: "B) VUCA Prime readiness (highlight)",
      bHintHtml:
        '5 questions per dimension – answer as <span class="pill green">Green</span> / <span class="pill yellow">Amber</span> / <span class="pill red">Red</span>. <strong>Only then</strong> does the roadmap become “smart”.',
      primeMeta: "5 questions · Green/Amber/Red",
      tl: [
        {k:"red", label:"Red", v:1},
        {k:"yellow", label:"Amber", v:2},
        {k:"green", label:"Green", v:3},
      ],
      prime: [
        {
          key:"V",
          name:"Vision (response to volatility)",
          hint:"Provide direction, shorten cadence, still decide steadily.",
          qs:[
            "We have a clear north star (vision) that guides decisions.",
            "Priorities for the next 2–4 weeks are visible and binding.",
            "We have clear decision rules (what is decided immediately vs. escalated).",
            "We plan rolling (cadence) instead of rigid (annual plan).",
            "Buffers/reserves are intentionally planned (time, capacity, budget)."
          ]
        },
        {
          key:"U",
          name:"Understanding (response to uncertainty)",
          hint:"Hypotheses instead of claims – learn faster than guessing.",
          qs:[
            "Assumptions are visible (hypothesis backlog / decision log).",
            "We use pre-mortems or risk checks before important steps.",
            "We work with scenarios (best/base/worst) instead of “one plan”.",
            "We actively reduce uncertainty through data/feedback (short cycles).",
            "We test small (MVP/experiments) before investing big."
          ]
        },
        {
          key:"C",
          name:"Clarity (response to complexity)",
          hint:"Understand the system, create focus, identify leverage.",
          qs:[
            "We understand key interactions (system map / cause–effect).",
            "Stakeholders/roles are clear (influence, impact, owner).",
            "We visualize work (Kanban) and limit WIP (focus).",
            "We simplify intentionally (leverage/80–20) instead of tackling everything at once.",
            "We think in time horizons (today–tomorrow–next)."
          ]
        },
        {
          key:"A",
          name:"Agility (response to ambiguity)",
          hint:"Shared definitions + fast adaptation while doing.",
          qs:[
            "Terms/success are defined (DoD/DoR, success criteria).",
            "Alignment is explicit (goal/non-goal, constraints, trade-offs).",
            "Decisions are role-based (RACI/DACI) and traceable.",
            "We use examples/story mapping instead of abstractions only.",
            "We iterate actively (retro/learnings) and adjust course quickly."
          ]
        }
      ],

      sec5Title: "5. Visualization (Dashboard)",
      sec5Sub: "3 layers: radar (highlight), matrix, gap. Each graphic is exportable.",
      vizRadarTitle: "VUCA Meter (Radar) – multi overlay",
      vizRadarSub: "Polygons per world + optional overall + Prime readiness",
      radarBtn: "Radar PNG",
      radarHint:
        "Tip: use the legend to toggle worlds on/off. “Prime” shows response capability (Vision/Understanding/Clarity/Agility) on the same 1–5 scale.",
      vizMatrixTitle: "VUCA Matrix (2×2)",
      vizMatrixSub: "x = U+A (learning) · y = V+C (deliver/steer)",
      matrixBtn: "Matrix PNG",
      matrixHint:
        "Points W1–W4 show: one case can contain multiple “worlds” → therefore multiple points.",
      vizGapTitle: "VUCA gap (pressure ↔ readiness)",
      vizGapSub: "Where is pressure higher than response capability?",
      gapBtn: "Gap PNG",
      gapNoData:
        "No ratings yet. Create at least one world and answer Prime questions (Green/Amber/Red).",

      sec6Title: "6. Method selection & tools (decision output)",
      sec6Sub: "The output ends with concrete tool suggestions – per dimension and as a priority list.",
      autoRecTitle: "Automatic recommendation (top priorities)",
      autoRecEmpty: "No data yet. Rate worlds and Prime questions.",

      sec7Title: "7. Actions (Roadmap)",
      sec7Sub: "Per world: suggested loop (PDCA/DCPA) + next steps (48h / 2 weeks / 4–8 weeks).",

      sec8Title: "8. Export & data",
      sec8Sub: "Export all graphics + JSON import/export (at the end, as requested).",
      exportGraphicsTitle: "Graphic export (PNG)",
      exportAllPng: "Whole dashboard PNG",
      exportRadarPng2: "Radar PNG",
      exportMatrixPng2: "Matrix PNG",
      exportGapPng2: "Gap PNG",
      exportHint: "Exports use the current live state. Ideal for documentation/slides.",
      jsonTitle: "JSON import/export",
      btnExportJson: "Save JSON",
      btnImportJson: "Load JSON",
      jsonHint: "JSON contains case + worlds + Prime answers. No live preview (as requested).",

      footerLead: "Further reading:",
      footerLex: "VUCA glossary",
      footerSem: "VUCA seminar",
      footerOpex: "OPEX training",

      tooltipV: "V – Volatility / Vision",
      tooltipU: "U – Uncertainty / Understanding",
      tooltipC: "C – Complexity / Clarity",
      tooltipA: "A – Ambiguity / Agility",

      dsOverall: "Overall (avg)",
      dsPrime: "Prime (readiness)",

      axisX: "U + A  →  Learning / clarification",
      axisY: "↑  V + C  (Steer / deliver)",
      q1Main: "Focus: Flow",
      q1Sub: "C/V high · U/A low",
      q2Main: "Focus: Learn",
      q2Sub: "C/V high · U/A high",
      q3Main: "Focus: Stabilize",
      q3Sub: "C/V low · U/A low",
      q4Main: "Focus: Experiment",
      q4Sub: "C/V low · U/A high",

      overallLabel: "Overall",

      tools: {
        V: {
          title: "Volatility → Vision",
          desc: "When conditions change fast: shorten cadence, keep direction.",
          tools: [
            "OODA loop (Observe–Orient–Decide–Act)",
            "Rolling planning / re-plan cadence (2–4 weeks)",
            "MoSCoW / Eisenhower prioritization",
            "Kanban + WIP limits (focus over parallelism)",
            "Buffer planning / 15% rule (plan for volatility)",
            "Light OKRs for focus & measurability"
          ]
        },
        U: {
          title: "Uncertainty → Understanding",
          desc: "When information is missing: make hypotheses visible, learn instead of guessing.",
          tools: [
            "Hypothesis backlog / assumption log",
            "Pre-mortem (what could go wrong?)",
            "Scenario planning (best/base/worst)",
            "Cone of uncertainty (deliberate narrowing)",
            "Experiment design / MVP thinking (test small)",
            "Decision log + re-evaluation triggers"
          ]
        },
        C: {
          title: "Complexity → Clarity",
          desc: "When cause–effect isn’t linear: understand the system, take safe steps.",
          tools: [
            "System mapping / causal loop thinking",
            "Stakeholder map (influence/impact)",
            "Value stream view / light Wardley mapping",
            "Safe-to-fail experiments (multiple small bets)",
            "Three horizons thinking",
            "A3 problem solving (Lean, structured)"
          ]
        },
        A: {
          title: "Ambiguity → Agility",
          desc: "When terms/goals differ: create shared language + adapt quickly while doing.",
          tools: [
            "Definition of Done / Definition of Ready",
            "Alignment canvas (goal/non-goal, criteria, constraints)",
            "RACI / DACI (clarify roles & decisions)",
            "Context check: “what does this mean in daily work?”",
            "Story mapping / examples over abstractions",
            "Retrospectives (Start/Stop/Continue) – systematize learning"
          ]
        }
      },

      loopNotes: {
        both: "Two-handed: delivery + experiments. Use DCPA for learning and PDCA for stable sub-tasks.",
        learn: "High uncertainty/ambiguity: run small experiments first, then plan.",
        deliver: "High volatility/complexity but structurable: iterate plan/do/check/adjust.",
        normal: "Moderate situation: plan small, work transparently, sharpen regularly."
      },

      steps48: {
        dcpa: [
          "Do: define 1–2 safe-to-fail experiments (small, reversible, measurable).",
          "Check: after 24–48h gather signals (data/feedback, stop criteria).",
          "Plan: set the next hypothesis, adjust the experiment."
        ],
        pdca: [
          "Plan: set goal + scope + board (Kanban, WIP limit).",
          "Do: start small (1–2 deliverables), clarify ownership.",
          "Check: after 48h status & blockers, adjust for the next cycle."
        ]
      },
      steps2w: {
        dcpa: [
          "Run 2–3 experiments in parallel (max 2 weeks), with clear metrics.",
          "Scale winners, stop losers, document learnings.",
          "Maintain a decision log: what was decided and why?"
        ],
        pdca: [
          "Rolling planning (2 weeks): lock priorities, keep the rest flexible.",
          "Risk / pre-mortem for critical paths.",
          "Review: measurable results + plan next iteration."
        ]
      },
      steps8w: [
        "Stabilize & standardize: what works becomes SOP/checklist.",
        "Close gaps: improve the weakest Prime dimension deliberately (training/process).",
        "Measurement system: define KPIs + triggers for re-planning."
      ],

      recNoPrime: "Answer Prime questions (Green/Amber/Red) so the tool can prioritize gaps.",
      recTemplate: (topP, topG, avg, r, b) => `
        <div class="vuca-text">
          <strong>Highest VUCA pressure:</strong> ${topP.k} (${topP.v}/5).<br/>
          <strong>Largest gap:</strong> ${topG.k} (pressure ${avg[topG.k]}/5 vs. readiness ${r}/5 → gap ${topG.g > 0 ? "+"+topG.g : topG.g}).<br/><br/>
          <strong>Recommended focus:</strong> <em>${esc(b.title)}</em><br/>
          Start with these 3 tools:
          <ul style="margin:8px 0 0 18px;">
            <li>${esc(b.tools[0])}</li>
            <li>${esc(b.tools[1])}</li>
            <li>${esc(b.tools[2])}</li>
          </ul>
        </div>
      `,

      insightNeedPrime: (title, team, goal) => `
        <strong>Case:</strong> ${title}<br/>
        <span style="color:#64748b">Context/team:</span> <strong>${team}</strong> · <span style="color:#64748b">Goal:</span> <strong>${goal}</strong><br/><br/>
        <strong>Next step:</strong> answer Prime questions (Green/Amber/Red) so the tool can prioritize gap + roadmap.
      `,
      insightTemplate: (title, team, goal, top, worstTxt) => `
        <strong>Case:</strong> ${title}<br/>
        <span style="color:#64748b">Context/team:</span> <strong>${team}</strong> · <span style="color:#64748b">Goal:</span> <strong>${goal}</strong><br/><br/>
        <strong>Insights:</strong><br/>
        1) Highest VUCA pressure is <strong>${top.k}</strong> (${top.v}/5).<br/>
        2) Largest gap is <strong>${esc(worstTxt)}</strong>.<br/>
        3) Recommendation: use tools first where the <strong>gap</strong> is largest (build readiness), then stabilize/standardize.
      `,

      tFieldsCleared: "Fields cleared.",
      tBackupSaved: "Backup saved.",
      tNoBackup: "No backup found.",
      tBackupLoaded: "Backup loaded.",
      tWorldAdded: "World added.",
      tJsonLoaded: "JSON loaded.",
      tJsonInvalid: "Invalid JSON.",
      tJsonLoadFail: "Could not load JSON.",
      tExportFail: "Export failed. Check browser permissions.",
      confirmClearAll: "Delete everything (case, worlds, prime)?",
      sec5RadarLegendAria: "Radar legend"
    }
  };

  let currentLang = (localStorage.getItem(LANG_KEY)
    || (navigator.language && navigator.language.toLowerCase().startsWith("de") ? "de" : "en"));
  if(currentLang !== "de" && currentLang !== "en") currentLang = "de";

  function t(key){
    const pack = I18N[currentLang] || I18N.de;
    return (pack && pack[key] != null) ? pack[key] : key;
  }
  function pack(){
    return I18N[currentLang] || I18N.de;
  }

  // ----------------------------
  // Helpers (existing)
  // ----------------------------
  function toast(msg){
    const el = $("#toast");
    if(!el) return;
    el.textContent = msg;
    el.classList.add("show");
    window.clearTimeout(toast._tmr);
    toast._tmr = window.setTimeout(() => el.classList.remove("show"), 2600);
  }
  function announce(msg){
    const a = $("#ariaStatus");
    if(a) a.textContent = msg;
  }
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
  function esc(s){
    return String(s ?? "")
      .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
  }

  // ----------------------------
  // Language switch UI (injected, no HTML changes needed)
  // ----------------------------
  function ensureLangSwitch(){
    const sec1 = ROOT.querySelector('section[aria-labelledby="vuca-sec1"]');
    if(!sec1) return;

    const head = sec1.querySelector(".vuca-card-head");
    if(!head) return;

    if(head.querySelector("#btnLangDE")) return; // already there

    // wrap existing badge
    const badge = head.querySelector(".vuca-badge");
    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "10px";
    actions.style.alignItems = "center";
    actions.style.flexWrap = "wrap";
    actions.style.justifyContent = "flex-end";

    const switchWrap = document.createElement("div");
    switchWrap.style.display = "flex";
    switchWrap.style.gap = "8px";
    switchWrap.style.alignItems = "center";

    const bDE = document.createElement("button");
    bDE.type = "button";
    bDE.className = "vuca-btn small";
    bDE.id = "btnLangDE";
    bDE.textContent = "DE";

    const bEN = document.createElement("button");
    bEN.type = "button";
    bEN.className = "vuca-btn small";
    bEN.id = "btnLangEN";
    bEN.textContent = "EN";

    switchWrap.appendChild(bDE);
    switchWrap.appendChild(bEN);
    actions.appendChild(switchWrap);

    if(badge){
      actions.appendChild(badge);
      head.appendChild(actions);
    }else{
      head.appendChild(actions);
    }

    bDE.addEventListener("click", ()=> setLanguage("de"));
    bEN.addEventListener("click", ()=> setLanguage("en"));

    updateLangButtonState();
  }

  function updateLangButtonState(){
    const bDE = $("#btnLangDE");
    const bEN = $("#btnLangEN");
    if(bDE) bDE.classList.toggle("primary", currentLang === "de");
    if(bEN) bEN.classList.toggle("primary", currentLang === "en");
  }

  function setLanguage(lang){
    if(lang !== "de" && lang !== "en") lang = "de";
    currentLang = lang;
    localStorage.setItem(LANG_KEY, currentLang);
    state.lang = currentLang;

    applyStaticI18n();
    buildWorldList();
    buildPrimeGrid();
    scheduleUpdate();
    updateLangButtonState();
    toast(currentLang === "de" ? "Sprache: Deutsch" : "Language: English");
  }

  // ----------------------------
  // Apply static texts (patch existing DOM)
  // ----------------------------
  function applyStaticI18n(){
    // SECTION 1
    const sec1 = ROOT.querySelector('section[aria-labelledby="vuca-sec1"]');
    if(sec1){
      const h2 = sec1.querySelector("#vuca-sec1");
      if(h2) h2.textContent = t("sec1Title");
      const sub = sec1.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.innerHTML = t("sec1SubHtml");
      const badge = sec1.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeDecision");

      const blocks = sec1.querySelectorAll(".vuca-content .vuca-grid-2 .vuca-block");
      if(blocks[0]){
        const h3 = blocks[0].querySelector("h3");
        const ul = blocks[0].querySelector("ul");
        if(h3) h3.textContent = t("goalTitle");
        if(ul) ul.innerHTML = t("goalListHtml");
      }
      if(blocks[1]){
        const h3 = blocks[1].querySelector("h3");
        const ol = blocks[1].querySelector("ol");
        if(h3) h3.textContent = t("howTitle");
        if(ol) ol.innerHTML = t("howListHtml");
      }
      const note = sec1.querySelector(".vuca-note");
      if(note) note.innerHTML = t("sec1NoteHtml");
    }

    // SECTION 2
    const sec2 = ROOT.querySelector('section[aria-labelledby="vuca-sec2"]');
    if(sec2){
      const h2 = sec2.querySelector("#vuca-sec2");
      if(h2) h2.textContent = t("sec2Title");
      const sub = sec2.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec2Sub");
      const badge = sec2.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeDefinition");

      const blocks = sec2.querySelectorAll(".vuca-content .vuca-grid-2 .vuca-block");
      if(blocks[0]){
        const h3 = blocks[0].querySelector("h3");
        const p = blocks[0].querySelector("p");
        if(h3) h3.textContent = t("sec2LeftTitle");
        if(p) p.textContent = t("sec2LeftText");
      }
      if(blocks[1]){
        const h3 = blocks[1].querySelector("h3");
        const p = blocks[1].querySelector("p");
        if(h3) h3.textContent = t("sec2RightTitle");
        if(p) p.textContent = t("sec2RightText");
      }
      const hint = sec2.querySelector(".vuca-hint");
      if(hint) hint.innerHTML = t("sec2Hint");
    }

    // SECTION 3
    const sec3 = ROOT.querySelector('section[aria-labelledby="vuca-sec3"]');
    if(sec3){
      const h2 = sec3.querySelector("#vuca-sec3");
      if(h2) h2.textContent = t("sec3Title");
      const sub = sec3.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec3Sub");
      const badge = sec3.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeCase");

      const l1 = sec3.querySelector('label[for="caseTitle"]');
      const l2 = sec3.querySelector('label[for="caseContextTeam"]');
      const l3 = sec3.querySelector('label[for="caseDesc"]');
      const l4 = sec3.querySelector('label[for="caseGoal"]');
      if(l1) l1.textContent = t("labelCaseTitle");
      if(l2) l2.textContent = t("labelCaseTeam");
      if(l3) l3.textContent = t("labelCaseDesc");
      if(l4) l4.textContent = t("labelCaseGoal");

      const i1 = $("#caseTitle");
      const i2 = $("#caseContextTeam");
      const i3 = $("#caseDesc");
      const i4 = $("#caseGoal");
      if(i1) i1.placeholder = t("phCaseTitle");
      if(i2) i2.placeholder = t("phCaseTeam");
      if(i3) i3.placeholder = t("phCaseDesc");
      if(i4) i4.placeholder = t("phCaseGoal");

      const b1 = $("#btnResetCase");
      const b2 = $("#btnBackup");
      const b3 = $("#btnRestore");
      const b4 = $("#btnClearAll");
      if(b1) b1.textContent = t("btnResetCase");
      if(b2) b2.textContent = t("btnBackup");
      if(b3) b3.textContent = t("btnRestore");
      if(b4) b4.textContent = t("btnClearAll");
    }

    // SECTION 4
    const sec4 = ROOT.querySelector('section[aria-labelledby="vuca-sec4"]');
    if(sec4){
      const h2 = sec4.querySelector("#vuca-sec4");
      if(h2) h2.textContent = t("sec4Title");
      const sub = sec4.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec4Sub");
      const badge = sec4.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeAssessment");

      const aH3 = sec4.querySelector(".vuca-row-head .vuca-row-title .vuca-h3");
      const aHint = sec4.querySelector(".vuca-row-head .vuca-row-title .vuca-hint");
      if(aH3) aH3.textContent = t("aTitle");
      if(aHint) aHint.textContent = t("aHint");
      const add = $("#btnAddWorld");
      if(add) add.textContent = t("btnAddWorld");
      const wl = $("#worldList");
      if(wl) wl.setAttribute("aria-label", t("worldListAria"));

      // B heading + hint
      const bHead = sec4.querySelectorAll(".vuca-row-head")[1];
      if(bHead){
        const bH3 = bHead.querySelector(".vuca-h3");
        const bHint = bHead.querySelector(".vuca-hint");
        if(bH3) bH3.textContent = t("bTitle");
        if(bHint) bHint.innerHTML = t("bHintHtml");
      }
    }

    // SECTION 5
    const sec5 = ROOT.querySelector('section[aria-labelledby="vuca-sec5"]');
    if(sec5){
      const h2 = sec5.querySelector("#vuca-sec5");
      if(h2) h2.textContent = t("sec5Title");
      const sub = sec5.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec5Sub");
      const badge = sec5.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeVisuals");

      // Radar texts
      const radarTitle = sec5.querySelector(".viz-card:nth-child(1) .viz-title");
      const radarSub = sec5.querySelector(".viz-card:nth-child(1) .viz-sub");
      if(radarTitle) radarTitle.textContent = t("vizRadarTitle");
      if(radarSub) radarSub.textContent = t("vizRadarSub");
      const rBtn = $("#exportRadarPng");
      if(rBtn) rBtn.textContent = t("radarBtn");
      const radarHint = $("#radarHint");
      if(radarHint) radarHint.textContent = t("radarHint");

      // Matrix texts
      const matrixTitle = sec5.querySelector(".viz-card:nth-child(2) .viz-title");
      const matrixSub = sec5.querySelector(".viz-card:nth-child(2) .viz-sub");
      if(matrixTitle) matrixTitle.textContent = t("vizMatrixTitle");
      if(matrixSub) matrixSub.textContent = t("vizMatrixSub");
      const mBtn = $("#exportMatrixPng");
      if(mBtn) mBtn.textContent = t("matrixBtn");
      const matrixHint = sec5.querySelector(".viz-card:nth-child(2) .vuca-hint");
      if(matrixHint) matrixHint.textContent = t("matrixHint");

      // Gap texts
      const gapTitle = sec5.querySelector(".viz-card:nth-child(3) .viz-title");
      const gapSub = sec5.querySelector(".viz-card:nth-child(3) .viz-sub");
      if(gapTitle) gapTitle.textContent = t("vizGapTitle");
      if(gapSub) gapSub.textContent = t("vizGapSub");
      const gBtn = $("#exportGapPng");
      if(gBtn) gBtn.textContent = t("gapBtn");

      // Default insight if empty
      const insight = $("#insightBox");
      if(insight && insight.textContent && insight.textContent.trim().length){
        // If tool already wrote something, leave it. Otherwise set default later in updateInsights.
      }
    }

    // SECTION 6
    const sec6 = ROOT.querySelector('section[aria-labelledby="vuca-sec6"]');
    if(sec6){
      const h2 = sec6.querySelector("#vuca-sec6");
      if(h2) h2.textContent = t("sec6Title");
      const sub = sec6.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec6Sub");
      const badge = sec6.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeTools");
      const h3 = sec6.querySelector("#autoRecommendations .vuca-h3");
      if(h3) h3.textContent = t("autoRecTitle");
      const txt = $("#autoRecText");
      if(txt && (!txt.textContent || txt.textContent.trim().length===0)) txt.textContent = t("autoRecEmpty");
    }

    // SECTION 7
    const sec7 = ROOT.querySelector('section[aria-labelledby="vuca-sec7"]');
    if(sec7){
      const h2 = sec7.querySelector("#vuca-sec7");
      if(h2) h2.textContent = t("sec7Title");
      const sub = sec7.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec7Sub");
      const badge = sec7.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeRoadmap");
    }

    // SECTION 8
    const sec8 = ROOT.querySelector('section[aria-labelledby="vuca-sec8"]');
    if(sec8){
      const h2 = sec8.querySelector("#vuca-sec8");
      if(h2) h2.textContent = t("sec8Title");
      const sub = sec8.querySelector(".vuca-card-head .vuca-sub");
      if(sub) sub.textContent = t("sec8Sub");
      const badge = sec8.querySelector(".vuca-badge");
      if(badge) badge.textContent = t("badgeExport");

      const leftH3 = sec8.querySelector(".vuca-grid-2 .vuca-block:nth-child(1) .vuca-h3");
      if(leftH3) leftH3.textContent = t("exportGraphicsTitle");
      const allBtn = $("#exportAllPng");
      const r2 = $("#exportRadarPng2");
      const m2 = $("#exportMatrixPng2");
      const g2 = $("#exportGapPng2");
      if(allBtn) allBtn.textContent = t("exportAllPng");
      if(r2) r2.textContent = t("exportRadarPng2");
      if(m2) m2.textContent = t("exportMatrixPng2");
      if(g2) g2.textContent = t("exportGapPng2");
      const leftHint = sec8.querySelector(".vuca-grid-2 .vuca-block:nth-child(1) .vuca-hint");
      if(leftHint) leftHint.textContent = t("exportHint");

      const rightH3 = sec8.querySelector(".vuca-grid-2 .vuca-block:nth-child(2) .vuca-h3");
      if(rightH3) rightH3.textContent = t("jsonTitle");
      const j1 = $("#btnExportJson");
      const j2 = $("#btnImportJson");
      if(j1) j1.textContent = t("btnExportJson");
      if(j2) j2.textContent = t("btnImportJson");
      const rightHint = sec8.querySelector(".vuca-grid-2 .vuca-block:nth-child(2) .vuca-hint");
      if(rightHint) rightHint.textContent = t("jsonHint");
    }

    // Footer
    const f = ROOT.querySelector(".vuca-footer-links");
    if(f){
      const strong = f.querySelector("strong");
      const links = f.querySelectorAll("a");
      if(strong) strong.textContent = t("footerLead");
      if(links[0]) links[0].textContent = t("footerLex");
      if(links[1]) links[1].textContent = t("footerSem");
      if(links[2]) links[2].textContent = t("footerOpex");
    }

    // update badge texts in other section headers (they reuse .vuca-badge)
    const sec2 = ROOT.querySelector('section[aria-labelledby="vuca-sec2"] .vuca-badge'); if(sec2) sec2.textContent = t("badgeDefinition");
    const sec3 = ROOT.querySelector('section[aria-labelledby="vuca-sec3"] .vuca-badge'); if(sec3) sec3.textContent = t("badgeCase");
    const sec4 = ROOT.querySelector('section[aria-labelledby="vuca-sec4"] .vuca-badge'); if(sec4) sec4.textContent = t("badgeAssessment");
    const sec5 = ROOT.querySelector('section[aria-labelledby="vuca-sec5"] .vuca-badge'); if(sec5) sec5.textContent = t("badgeVisuals");
    const sec6 = ROOT.querySelector('section[aria-labelledby="vuca-sec6"] .vuca-badge'); if(sec6) sec6.textContent = t("badgeTools");
    const sec7 = ROOT.querySelector('section[aria-labelledby="vuca-sec7"] .vuca-badge'); if(sec7) sec7.textContent = t("badgeRoadmap");
    const sec8 = ROOT.querySelector('section[aria-labelledby="vuca-sec8"] .vuca-badge'); if(sec8) sec8.textContent = t("badgeExport");
  }

  // ----------------------------
  // Worlds (1..4) + state
  // ----------------------------
  const WORLD_MAX = 4;

  function cryptoId(){
    try{ return crypto.randomUUID(); }catch{ return "id_" + Math.random().toString(16).slice(2); }
  }
  function defaultWorld(i){
    return {
      id: cryptoId(),
      name: `W${i}`,
      note: "",
      V: 3, U: 3, C: 3, A: 3
    };
  }

  let state = {
    lang: currentLang,
    caseTitle:"",
    caseContextTeam:"",
    caseDesc:"",
    caseGoal:"",
    worlds: [ defaultWorld(1) ],
    prime: { V:[null,null,null,null,null], U:[null,null,null,null,null], C:[null,null,null,null,null], A:[null,null,null,null,null] },
    ts: new Date().toISOString()
  };

  // ----------------------------
  // Persist
  // ----------------------------
  function persist(){
    state.lang = currentLang;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }
  function restore(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return false;
    try{
      const p = JSON.parse(raw);
      if(!p || typeof p !== "object") return false;

      // language from saved state (optional)
      const savedLang = String(p.lang ?? "");
      if(savedLang === "de" || savedLang === "en"){
        currentLang = savedLang;
        localStorage.setItem(LANG_KEY, currentLang);
      }

      state.lang = currentLang;
      state.caseTitle = String(p.caseTitle ?? "");
      state.caseContextTeam = String(p.caseContextTeam ?? "");
      state.caseDesc = String(p.caseDesc ?? "");
      state.caseGoal = String(p.caseGoal ?? "");

      state.worlds = Array.isArray(p.worlds) && p.worlds.length
        ? p.worlds.slice(0, WORLD_MAX).map((w, idx)=>({
            id: String(w.id ?? cryptoId()),
            name: String(w.name ?? `W${idx+1}`),
            note: String(w.note ?? ""),
            V: clamp(Number(w.V ?? 3), 1, 5),
            U: clamp(Number(w.U ?? 3), 1, 5),
            C: clamp(Number(w.C ?? 3), 1, 5),
            A: clamp(Number(w.A ?? 3), 1, 5),
          }))
        : [ defaultWorld(1) ];

      const pr = p.prime || {};
      ["V","U","C","A"].forEach(k=>{
        const arr = Array.isArray(pr[k]) ? pr[k] : [];
        state.prime[k] = Array.from({length:5}, (_,i)=>{
          const v = arr[i];
          return (v===1||v===2||v===3) ? v : null;
        });
      });

      state.ts = String(p.ts ?? new Date().toISOString());
      return true;
    }catch(e){
      return false;
    }
  }

  // ----------------------------
  // UI builders
  // ----------------------------
  function syncCaseInputs(){
    $("#caseTitle").value = state.caseTitle;
    $("#caseContextTeam").value = state.caseContextTeam;
    $("#caseDesc").value = state.caseDesc;
    $("#caseGoal").value = state.caseGoal;
  }

  function cssId(s){
    return String(s).replace(/[^a-zA-Z0-9_-]/g,"_");
  }

  function sliderHtml(w, key, label){
    const val = w[key];
    const id = cssId(w.id);
    return `
      <div class="slider">
        <div class="slider-top">
          <div class="slider-label">${key}) ${esc(label)}</div>
          <div class="slider-val">${esc(t("valueLabel"))}: <span id="world_${id}_${key}_v">${val}</span></div>
        </div>
        <input id="world_${id}_${key}" type="range" min="1" max="5" value="${val}" />
      </div>
    `;
  }

  function buildWorldList(){
    const host = $("#worldList");
    host.innerHTML = "";

    state.worlds.forEach((w, idx)=>{
      const card = document.createElement("div");
      card.className = "world-card";

      const chip = `${esc(t("chipWorld"))} ${idx+1} / ${state.worlds.length}`;
      const rmBtn = (state.worlds.length > 1)
        ? `<button type="button" class="vuca-btn small danger" data-act="rmWorld" data-id="${esc(w.id)}">${esc(t("removeWorld"))}</button>`
        : "";

      card.innerHTML = `
        <div class="world-head">
          <div>
            <p class="world-name">${esc(w.name || `W${idx+1}`)}</p>
            <p class="world-mini">${esc(t("worldMini"))}</p>
          </div>
          <div class="world-actions">
            <span class="chip">${chip}</span>
            ${rmBtn}
          </div>
        </div>

        <div class="vuca-field" style="margin-bottom:10px;">
          <label class="vuca-label" for="worldName_${esc(w.id)}">${esc(t("worldNameLabel"))}</label>
          <input class="vuca-input" id="worldName_${esc(w.id)}" type="text" value="${esc(w.name)}" placeholder="${esc(t("worldNamePh"))}" />
        </div>

        <div class="vuca-field" style="margin-bottom:12px;">
          <label class="vuca-label" for="worldNote_${esc(w.id)}">${esc(t("worldNoteLabel"))}</label>
          <input class="vuca-input" id="worldNote_${esc(w.id)}" type="text" value="${esc(w.note)}" placeholder="${esc(t("worldNotePh"))}" />
        </div>

        <div class="slider-grid">
          ${sliderHtml(w, "V", pack().dims.V)}
          ${sliderHtml(w, "U", pack().dims.U)}
          ${sliderHtml(w, "C", pack().dims.C)}
          ${sliderHtml(w, "A", pack().dims.A)}
        </div>
      `;
      host.appendChild(card);
    });

    // Wire up events
    state.worlds.forEach(w=>{
      const nameEl = $(`#worldName_${cssId(w.id)}`);
      const noteEl = $(`#worldNote_${cssId(w.id)}`);
      if(nameEl){
        nameEl.addEventListener("input", ()=>{
          w.name = nameEl.value.trim();
          scheduleUpdate();
        });
      }
      if(noteEl){
        noteEl.addEventListener("input", ()=>{
          w.note = noteEl.value.trim();
          scheduleUpdate();
        });
      }
      ["V","U","C","A"].forEach(k=>{
        const r = $(`#world_${cssId(w.id)}_${k}`);
        const v = $(`#world_${cssId(w.id)}_${k}_v`);
        if(r && v){
          r.addEventListener("input", ()=>{
            const n = clamp(Number(r.value), 1, 5);
            w[k] = n;
            v.textContent = String(n);
            scheduleUpdate();
          });
        }
      });
    });

    // Remove buttons
    host.querySelectorAll('[data-act="rmWorld"]').forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const id = btn.getAttribute("data-id");
        state.worlds = state.worlds.filter(w=>w.id !== id);
        state.worlds.forEach((w, i)=>{ if(!w.name) w.name = `W${i+1}`; });
        buildWorldList();
        scheduleUpdate();
      });
    });

    // Add world button enabled/disabled
    $("#btnAddWorld").disabled = state.worlds.length >= WORLD_MAX;
  }

  function primeDef(){ return pack().prime; }
  function tlDef(){ return pack().tl; }

  function primeQHtml(dimKey, idx, text){
    const group = `prime_${dimKey}_${idx}`;
    const aria = `${dimKey} Q${idx+1}`;
    return `
      <div class="qrow" data-prime-row="${group}">
        <p class="qtext">${esc(text)}</p>
        <div class="traffic" role="group" aria-label="${esc(aria)}">
          ${tlDef().map(o=>`
            <label class="tl ${o.k}" data-val="${o.v}" title="${esc(o.label)}">
              <span class="dot" aria-hidden="true"></span>
              ${esc(o.label)}
              <input type="radio" name="${group}" value="${o.v}">
            </label>
          `).join("")}
        </div>
      </div>
    `;
  }

  function buildPrimeGrid(){
    const host = $("#primeGrid");
    host.innerHTML = "";

    primeDef().forEach(dim=>{
      const card = document.createElement("div");
      card.className = "prime-card";
      card.innerHTML = `
        <div class="prime-title">
          <h4>${esc(dim.key)} · ${esc(dim.name)}</h4>
          <div class="prime-meta">${esc(t("primeMeta"))}</div>
        </div>
        <div class="vuca-hint" style="margin:0 0 10px;">${esc(dim.hint)}</div>
        ${dim.qs.map((qt, i)=> primeQHtml(dim.key, i, qt)).join("")}
      `;
      host.appendChild(card);
    });

    // Wire up selections
    primeDef().forEach(dim=>{
      dim.qs.forEach((_, i)=>{
        const groupName = `prime_${dim.key}_${i}`;
        const row = host.querySelector(`[data-prime-row="${groupName}"]`);
        if(!row) return;

        row.querySelectorAll("label.tl").forEach(lab=>{
          lab.addEventListener("click", ()=>{
            const v = Number(lab.getAttribute("data-val"));
            state.prime[dim.key][i] = (v===1||v===2||v===3) ? v : null;

            row.querySelectorAll("label.tl").forEach(x=>x.classList.remove("selected"));
            lab.classList.add("selected");

            scheduleUpdate();
          });
        });

        // initial highlight
        const current = state.prime[dim.key][i];
        if(current){
          const lab = row.querySelector(`label.tl[data-val="${current}"]`);
          if(lab) lab.classList.add("selected");
        }
      });
    });
  }

  // ----------------------------
  // Visuals: Radar (Chart.js), Matrix (SVG), Gap Bars
  // ----------------------------
  let radarChart = null;

  const palette = [
    {border:"rgba(17,85,178,.85)", fill:"rgba(17,85,178,.14)"},
    {border:"rgba(245,158,11,.90)", fill:"rgba(245,158,11,.14)"},
    {border:"rgba(22,163,74,.85)", fill:"rgba(22,163,74,.12)"},
    {border:"rgba(229,62,62,.85)", fill:"rgba(229,62,62,.12)"},
  ];

  function ensureRadar(){
    const canvas = $("#radarChart");
    const ctx = canvas.getContext("2d");

    const glow = {
      id: "glow",
      beforeDatasetsDraw(chart){
        const {ctx} = chart;
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.10)";
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
      },
      afterDatasetsDraw(chart){
        chart.ctx.restore();
      }
    };

    radarChart = new Chart(ctx, {
      type: "radar",
      data: { labels: ["V","U","C","A"], datasets: [] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 180 },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title(items){
                const l = items[0].label;
                return (l==="V") ? t("tooltipV")
                  : (l==="U") ? t("tooltipU")
                  : (l==="C") ? t("tooltipC")
                  : t("tooltipA");
              },
              label(ctx){ return `${ctx.dataset.label}: ${ctx.raw}`; }
            }
          }
        },
        scales: {
          r: {
            min: 1,
            max: 5,
            ticks: { stepSize: 1, backdropColor: "transparent" },
            grid: { color: "rgba(0,0,0,0.05)" },
            angleLines: { color: "rgba(0,0,0,0.05)" },
            pointLabels: { color: "#09387a", font: { size: 12, weight: "700" } }
          }
        },
        elements: { line: { borderWidth: 2 }, point: { radius: 3 } }
      },
      plugins: [glow]
    });
  }

  function primeReadiness5(){
    const out = {V:null,U:null,C:null,A:null, missing:false};
    ["V","U","C","A"].forEach(k=>{
      const arr = state.prime[k];
      const answered = arr.filter(v=>v===1||v===2||v===3);
      if(answered.length === 0){
        out[k] = null;
        out.missing = true;
        return;
      }
      const avg = answered.reduce((a,b)=>a+b,0)/answered.length; // 1..3
      out[k] = Math.round((1 + (avg - 1) * 2) * 10) / 10; // 1..5
      if(answered.length < 5) out.missing = true;
    });
    return out;
  }

  function worldPressureAvg(){
    const n = state.worlds.length || 1;
    const sum = {V:0,U:0,C:0,A:0};
    state.worlds.forEach(w=>{
      sum.V += w.V; sum.U += w.U; sum.C += w.C; sum.A += w.A;
    });
    return {
      V: +(sum.V/n).toFixed(1),
      U: +(sum.U/n).toFixed(1),
      C: +(sum.C/n).toFixed(1),
      A: +(sum.A/n).toFixed(1),
    };
  }

  function updateRadar(){
    if(!radarChart) ensureRadar();

    const readiness = primeReadiness5();
    const datasets = [];

    state.worlds.forEach((w, i)=>{
      const col = palette[i % palette.length];
      const label = (w.name && w.name.trim()) ? w.name.trim() : `W${i+1}`;
      datasets.push({
        label,
        data: [w.V, w.U, w.C, w.A],
        borderColor: col.border,
        backgroundColor: col.fill,
        pointBackgroundColor: col.border,
        borderWidth: 2
      });
    });

    const avg = worldPressureAvg();
    datasets.push({
      label: t("dsOverall"),
      data: [avg.V, avg.U, avg.C, avg.A],
      borderColor: "rgba(15,23,42,.65)",
      backgroundColor: "rgba(15,23,42,.05)",
      pointBackgroundColor: "rgba(15,23,42,.75)",
      borderWidth: 2,
      borderDash: [6,4]
    });

    const prData = ["V","U","C","A"].map(k => readiness[k] ?? null);
    const hasAny = prData.some(v=>typeof v === "number");
    if(hasAny){
      datasets.push({
        label: t("dsPrime"),
        data: prData.map(v => v ?? 1),
        borderColor: "rgba(9,56,122,.85)",
        backgroundColor: "rgba(9,56,122,.10)",
        pointBackgroundColor: "rgba(9,56,122,.90)",
        borderWidth: 3,
        borderDash: [2,2]
      });
    }

    radarChart.data.datasets = datasets;
    radarChart.update();

    buildRadarLegend(datasets);
  }

  function buildRadarLegend(datasets){
    const host = $("#radarLegend");
    if(host) host.setAttribute("aria-label", t("sec5RadarLegendAria"));
    host.innerHTML = "";

    datasets.forEach((ds, i)=>{
      const item = document.createElement("div");
      item.className = "leg-item";
      item.innerHTML = `
        <span class="swatch" style="background:${ds.borderColor}"></span>
        ${esc(ds.label)}
      `;
      host.appendChild(item);

      item.addEventListener("click", ()=>{
        radarChart.data.datasets[i].hidden = !radarChart.data.datasets[i].hidden;
        item.classList.toggle("off", radarChart.data.datasets[i].hidden === true);
        radarChart.update();
      });

      if(datasets[i].hidden) item.classList.add("off");
    });
  }

  function addSvg(svg, tag, attrs){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    Object.entries(attrs).forEach(([k,v])=>el.setAttribute(k, String(v)));
    svg.appendChild(el);
    return el;
  }
  function addText(svg, x, y, text, anchor, cls, rotate=false, rx=0, ry=0){
    const tEl = addSvg(svg, "text", {
      x, y, "text-anchor": anchor,
      "font-family":"ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial",
      "font-weight": "800",
      "font-size": cls==="axis" ? "11" : (cls==="tick" ? "10" : "12"),
      "fill": cls==="axis" ? "#334155" : (cls==="tick" ? "#64748b" : "#0f172a")
    });
    if(rotate){
      tEl.setAttribute("transform", `rotate(-90 ${rx} ${ry})`);
    }
    tEl.textContent = text;
    return tEl;
  }
  function qLabel(svg, x, y, main, sub){
    addText(svg, x, y, main, "middle", "main");
    addText(svg, x, y+12, sub, "middle", "tick");
  }

  function renderMatrix(){
    const svg = $("#vucaMatrix");
    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const W=420,H=420,pad=44, top=24, innerW=W-pad-18, innerH=H-top-40;

    addSvg(svg, "rect", {x:0,y:0,width:W,height:H,fill:"#fff"});
    addSvg(svg, "rect", {x:pad,y:top,width:innerW,height:innerH,fill:"#fff",stroke:"rgba(17,85,178,.15)","stroke-width":"1"});

    addSvg(svg,"rect",{x:pad,y:top,width:innerW/2,height:innerH/2,fill:"rgba(22,163,74,.08)"});
    addSvg(svg,"rect",{x:pad+innerW/2,y:top,width:innerW/2,height:innerH/2,fill:"rgba(245,158,11,.10)"});
    addSvg(svg,"rect",{x:pad,y:top+innerH/2,width:innerW/2,height:innerH/2,fill:"rgba(17,85,178,.08)"});
    addSvg(svg,"rect",{x:pad+innerW/2,y:top+innerH/2,width:innerW/2,height:innerH/2,fill:"rgba(229,62,62,.07)"});

    addSvg(svg,"line",{x1:pad+innerW/2,y1:top,x2:pad+innerW/2,y2:top+innerH,stroke:"rgba(15,23,42,.25)","stroke-width":"1"});
    addSvg(svg,"line",{x1:pad,y1:top+innerH/2,x2:pad+innerW,y2:top+innerH/2,stroke:"rgba(15,23,42,.25)","stroke-width":"1"});

    addText(svg, pad+innerW/2, H-10, t("axisX"), "middle", "axis");
    addText(svg, 14, top+innerH/2, t("axisY"), "middle", "axis", true, 14, top+innerH/2);

    qLabel(svg, pad+innerW*0.25, top+innerH*0.22, t("q1Main"), t("q1Sub"));
    qLabel(svg, pad+innerW*0.75, top+innerH*0.22, t("q2Main"), t("q2Sub"));
    qLabel(svg, pad+innerW*0.25, top+innerH*0.72, t("q3Main"), t("q3Sub"));
    qLabel(svg, pad+innerW*0.75, top+innerH*0.72, t("q4Main"), t("q4Sub"));

    state.worlds.forEach((w, i)=>{
      const x01 = clamp((w.U + w.A)/10, 0, 1);
      const y01 = clamp((w.V + w.C)/10, 0, 1);

      const x = pad + innerW*x01;
      const y = top + innerH*(1 - y01);

      const col = palette[i % palette.length].border;
      addSvg(svg, "circle", {cx:x, cy:y, r:7, fill:col, stroke:"#0f172a","stroke-width":"1"});
      addText(svg, x, y-12, (w.name && w.name.trim()) ? w.name.trim() : `W${i+1}`, "middle", "tick");
    });

    const avg = worldPressureAvg();
    const x01 = clamp((avg.U + avg.A)/10, 0, 1);
    const y01 = clamp((avg.V + avg.C)/10, 0, 1);
    const ox = pad + innerW*x01;
    const oy = top + innerH*(1 - y01);

    addSvg(svg, "circle", {cx:ox, cy:oy, r:6, fill:"rgba(15,23,42,.65)", stroke:"#0f172a","stroke-width":"1"});
    addText(svg, ox, oy+20, t("overallLabel"), "middle", "tick");
  }

  function updateGapBars(){
    const host = $("#gapBars");
    host.innerHTML = "";

    const avg = worldPressureAvg();
    const readiness = primeReadiness5();

    const dims = [{k:"V"},{k:"U"},{k:"C"},{k:"A"}];

    dims.forEach(d=>{
      const pressure = avg[d.k];
      const ready = (typeof readiness[d.k] === "number") ? readiness[d.k] : null;
      const gap = (ready === null) ? null : +(pressure - ready).toFixed(1);

      const maxAbs = 4;
      const pct = gap === null ? 0 : clamp((Math.abs(gap)/maxAbs)*50, 0, 50);
      const left = gap === null ? 50 : (gap >= 0 ? 50 : 50 - pct);
      const width = gap === null ? 0 : pct;

      let color = "rgba(100,116,139,.0)";
      if(gap !== null){
        color = (gap >= 2) ? "rgba(229,62,62,.80)"
              : (gap >= 1) ? "rgba(245,158,11,.85)"
              : (gap >= 0) ? "rgba(22,163,74,.55)"
              : "rgba(22,163,74,.85)";
      }

      const row = document.createElement("div");
      row.className = "gap-row";
      row.innerHTML = `
        <div class="gap-k">${d.k}</div>
        <div class="bar">
          <div class="fill" style="left:${left}%; width:${width}%; background:${color};"></div>
        </div>
        <div class="gap-v">${gap === null ? "—" : (gap > 0 ? "+"+gap : String(gap))}</div>
      `;
      host.appendChild(row);
    });
  }

  // ----------------------------
  // Tools + Roadmap (now language-aware)
  // ----------------------------
  function toolbox(){ return pack().tools; }

  function buildToolGrid(){
    const host = $("#toolGrid");
    host.innerHTML = "";

    ["V","U","C","A"].forEach(k=>{
      const b = toolbox()[k];
      const card = document.createElement("div");
      card.className = "tool-card";
      card.innerHTML = `
        <h4>${esc(k)} · ${esc(b.title)}</h4>
        <p>${esc(b.desc)}</p>
        <ul>${b.tools.map(x=>`<li>${esc(x)}</li>`).join("")}</ul>
      `;
      host.appendChild(card);
    });
  }

  function chooseLoopForWorld(w){
    const learn = w.U + w.A;
    const deliver = w.V + w.C;

    if(learn >= 8 && deliver >= 8) return {loop:"DCPA", cls:"dcpa", note: pack().loopNotes.both};
    if(learn >= 8) return {loop:"DCPA", cls:"dcpa", note: pack().loopNotes.learn};
    if(deliver >= 8) return {loop:"PDCA", cls:"pdca", note: pack().loopNotes.deliver};
    return {loop:"PDCA", cls:"pdca", note: pack().loopNotes.normal};
  }

  function buildRoadmap(){
    const host = $("#roadmapBox");
    host.innerHTML = "";

    state.worlds.forEach((w,i)=>{
      const label = (w.name && w.name.trim()) ? w.name.trim() : `W${i+1}`;
      const l = chooseLoopForWorld(w);

      const steps48 = (l.loop === "DCPA") ? pack().steps48.dcpa : pack().steps48.pdca;
      const steps2w = (l.loop === "DCPA") ? pack().steps2w.dcpa : pack().steps2w.pdca;
      const steps8w = pack().steps8w;

      const item = document.createElement("div");
      item.className = "roadmap-item";
      item.innerHTML = `
        <div class="roadmap-top">
          <div class="roadmap-title">${esc(label)}</div>
          <div class="roadmap-loop ${l.cls}">${l.loop}</div>
        </div>
        <div class="vuca-hint" style="margin-top:6px;">${esc(l.note)}</div>

        <div class="vuca-divider" style="margin:10px 0;"></div>

        <div class="vuca-h3" style="margin:0 0 6px;">48h</div>
        <ul>${steps48.map(s=>`<li>${esc(s)}</li>`).join("")}</ul>

        <div class="vuca-h3" style="margin:10px 0 6px;">2 weeks</div>
        <ul>${steps2w.map(s=>`<li>${esc(s)}</li>`).join("")}</ul>

        <div class="vuca-h3" style="margin:10px 0 6px;">4–8 weeks</div>
        <ul>${steps8w.map(s=>`<li>${esc(s)}</li>`).join("")}</ul>
      `;
      host.appendChild(item);
    });

    // Fix the headers "2 weeks / 4–8 weeks" for DE:
    if(currentLang === "de"){
      host.querySelectorAll(".roadmap-item").forEach(item=>{
        const h3s = item.querySelectorAll(".vuca-h3");
        if(h3s[1]) h3s[1].textContent = "2 Wochen";
        if(h3s[2]) h3s[2].textContent = "4–8 Wochen";
      });
    }
  }

  function buildAutoRecommendations(){
    const avg = worldPressureAvg();
    const readiness = primeReadiness5();

    const pressureList = ["V","U","C","A"].map(k=>({k, v: avg[k]})).sort((a,b)=>b.v-a.v);
    const topP = pressureList[0];

    const gapList = ["V","U","C","A"].map(k=>{
      const r = (typeof readiness[k]==="number") ? readiness[k] : null;
      const g = (r===null) ? null : +(avg[k]-r).toFixed(1);
      return {k, g, r};
    }).filter(x=>x.g !== null).sort((a,b)=>b.g-a.g);

    const topG = gapList.length ? gapList[0] : null;

    let msg = "";
    if(!topG){
      msg = pack().recNoPrime;
    }else{
      const b = toolbox()[topG.k];
      msg = pack().recTemplate(topP, topG, avg, topG.r, b);
    }
    $("#autoRecText").innerHTML = msg;
  }

  function updateInsights(){
    const title = state.caseTitle ? esc(state.caseTitle) : "—";
    const team  = state.caseContextTeam ? esc(state.caseContextTeam) : "—";
    const goal  = state.caseGoal ? esc(state.caseGoal) : "—";

    const avg = worldPressureAvg();
    const readiness = primeReadiness5();

    const pSorted = ["V","U","C","A"].map(k=>({k, v: avg[k]})).sort((a,b)=>b.v-a.v);
    const top = pSorted[0];

    const gaps = ["V","U","C","A"].map(k=>{
      const r = (typeof readiness[k]==="number") ? readiness[k] : null;
      return {k, gap: (r===null ? null : +(avg[k]-r).toFixed(1)), r};
    });

    const answeredAny = gaps.some(x=>x.gap !== null);

    const gapSorted = gaps.filter(x=>x.gap !== null).sort((a,b)=>b.gap-a.gap);
    const worst = gapSorted[0] || null;

    const insight = $("#insightBox");
    if(!answeredAny){
      insight.innerHTML = pack().insightNeedPrime(title, team, goal);
      return;
    }

    const worstTxt = worst
      ? `${worst.k}: ${worst.gap>0?"+":""}${worst.gap} (${avg[worst.k]}/5 vs ${worst.r}/5)`
      : "—";

    insight.innerHTML = pack().insightTemplate(title, team, goal, top, worstTxt);
  }

  // ----------------------------
  // Export helpers
  // ----------------------------
  async function exportNodePng(node, filename){
    try{
      const canvas = await html2canvas(node, { scale: 2, backgroundColor: "#ffffff" });
      const a = document.createElement("a");
      a.download = filename;
      a.href = canvas.toDataURL("image/png");
      a.click();
    }catch(e){
      toast(t("tExportFail"));
    }
  }

  // ----------------------------
  // JSON import/export
  // ----------------------------
  function downloadJson(){
    state.lang = currentLang;
    state.ts = new Date().toISOString();
    const blob = new Blob([JSON.stringify(state, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "vuca-entscheidungsfinder.json";
    a.click();
    URL.revokeObjectURL(url);
  }
  function loadJsonFile(file){
    file.text().then(txt=>{
      const parsed = JSON.parse(txt);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(parsed));
      if(!restore()){
        toast(t("tJsonInvalid"));
        return;
      }
      applyStaticI18n();
      updateLangButtonState();
      syncCaseInputs();
      buildWorldList();
      buildPrimeGrid();
      scheduleUpdate();
      toast(t("tJsonLoaded"));
    }).catch(()=>{
      toast(t("tJsonLoadFail"));
    });
  }

  // ----------------------------
  // Update loop
  // ----------------------------
  let rafPending = false;
  function scheduleUpdate(){
    if(rafPending) return;
    rafPending = true;
    requestAnimationFrame(()=>{
      rafPending = false;
      updateRadar();
      renderMatrix();
      updateGapBars();
      buildToolGrid();
      buildAutoRecommendations();
      buildRoadmap();
      updateInsights();
      persist();
    });
  }

  // ----------------------------
  // Events: Case inputs
  // ----------------------------
  ["caseTitle","caseContextTeam","caseDesc","caseGoal"].forEach(id=>{
    const el = $("#"+id);
    el.addEventListener("input", ()=>{
      state[id] = el.value;
      scheduleUpdate();
    });
  });

  $("#btnResetCase").addEventListener("click", ()=>{
    state.caseTitle="";
    state.caseContextTeam="";
    state.caseDesc="";
    state.caseGoal="";
    syncCaseInputs();
    scheduleUpdate();
    toast(t("tFieldsCleared"));
  });

  $("#btnBackup").addEventListener("click", ()=>{
    persist();
    toast(t("tBackupSaved"));
  });
  $("#btnRestore").addEventListener("click", ()=>{
    const ok = restore();
    if(!ok){
      toast(t("tNoBackup"));
      return;
    }
    applyStaticI18n();
    updateLangButtonState();
    syncCaseInputs();
    buildWorldList();
    buildPrimeGrid();
    scheduleUpdate();
    toast(t("tBackupLoaded"));
  });

  $("#btnClearAll").addEventListener("click", ()=>{
    if(!confirm(t("confirmClearAll"))) return;
    localStorage.removeItem(STORAGE_KEY);
    state = {
      lang: currentLang,
      caseTitle:"",
      caseContextTeam:"",
      caseDesc:"",
      caseGoal:"",
      worlds:[ defaultWorld(1) ],
      prime:{ V:[null,null,null,null,null], U:[null,null,null,null,null], C:[null,null,null,null,null], A:[null,null,null,null,null] },
      ts: new Date().toISOString()
    };
    syncCaseInputs();
    buildWorldList();
    buildPrimeGrid();
    scheduleUpdate();
    toast(t("btnClearAll"));
  });

  $("#btnAddWorld").addEventListener("click", ()=>{
    if(state.worlds.length >= WORLD_MAX) return;
    state.worlds.push(defaultWorld(state.worlds.length+1));
    buildWorldList();
    scheduleUpdate();
    toast(t("tWorldAdded"));
  });

  // Exports
  $("#exportAllPng").addEventListener("click", ()=> exportNodePng(ROOT, "vuca-dashboard.png"));
  $("#exportRadarPng").addEventListener("click", ()=> exportNodePng($("#radarWrap"), "vuca-radar.png"));
  $("#exportMatrixPng").addEventListener("click", ()=> exportNodePng($("#matrixWrap"), "vuca-matrix.png"));
  $("#exportGapPng").addEventListener("click", ()=> exportNodePng($("#gapWrap"), "vuca-gap.png"));
  $("#exportRadarPng2").addEventListener("click", ()=> exportNodePng($("#radarWrap"), "vuca-radar.png"));
  $("#exportMatrixPng2").addEventListener("click", ()=> exportNodePng($("#matrixWrap"), "vuca-matrix.png"));
  $("#exportGapPng2").addEventListener("click", ()=> exportNodePng($("#gapWrap"), "vuca-gap.png"));

  // JSON
  $("#btnExportJson").addEventListener("click", downloadJson);
  $("#btnImportJson").addEventListener("click", ()=> $("#jsonFile").click());
  $("#jsonFile").addEventListener("change", (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    loadJsonFile(f);
    ev.target.value = "";
  });

  // ----------------------------
  // Init
  // ----------------------------
  restore();

  ensureLangSwitch();
  applyStaticI18n();
  updateLangButtonState();

  syncCaseInputs();
  buildWorldList();
  buildPrimeGrid();
  buildToolGrid();
  ensureRadar();

  // Footer year (auto)
  const y = new Date().getFullYear();
  const yEl = $("#copyrightYear");
  if(yEl) yEl.textContent = String(y);

  // set initial no-data text (gap)
  const insight = $("#insightBox");
  if(insight && (!insight.textContent || insight.textContent.trim().length===0)){
    insight.textContent = t("gapNoData");
  }

  scheduleUpdate();

})();
</script>
